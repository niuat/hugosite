[{
  "section": "Blog",
  "slug": "/hugosite/blog/249202/",
  "title": "使用pyinstaller打包为exe可执行程序遇见的一些坑",
  "description": "this is meta description",
  "date": "April 4, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://s2.loli.net/2024/09/02/VDijgJr6ZRpwInS.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://s2.loli.net/2024/09/02/VDijgJr6ZRpwInS.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n",
  "searchKeyword": "",
  "categories": "Application, Data",
  "tags": "nextjs, tailwind",
  "content":" 将一个处理本地 CSV 表格并生成图表的小程序转为 EXE 可执行程序时，我遇到了一些问题。这个程序使用了 pyecharts 包，但大多数打包程序与该包兼容性较差。由于表格必须本地处理，我需要找到解决方法。\n打包好的 EXE 程序需要处理当前工作目录下的 CSV 文件，但在使用 PyInstaller 打包后，程序解压到临时目录，导致程序找不到 CSV 文件并报错：“No CSV files found in the directory.”\n在遇到 PyInstaller 的问题后，我尝试了 py2exe 和 cx_Freeze，但也出现了类似的问题。因此，我决定回头排查 PyInstaller 的错误。\n第一个坑：打包后的exe占用空间大 打包成一个文件后，空间占用大的原因是直接使用了测试环境进行打包，默认将环境中所有依赖包都打包到 EXE 文件中，导致耗时长且占用空间大。\n解决办法：重新构建虚拟环境，在虚拟环境中添加好依赖后再进行打包。\n第二个坑：找不到依赖包 FileNotFoundError: [Errno 2] No such file or directory: \u0026#39;C:\\\\Users\\\\x\\\\AppData\\\\Local\\\\Temp\\\\_MEI6362\\\\pyecharts\\\\datasets\\\\map_filename.json\u0026#39; 在打包成一个文件后，运行时系统会创建一个临时目录，但在该目录中找不到 pyecharts 包所需的文件，导致报错。\n解决办法：使用 add-data 参数手动将依赖包加入打包文件中：\npyinstaller -F test.py --add-data python安装目录\\Lib\\site-packages\\pyecharts\\render\\templates;pyecharts/render/templates --add-data python安装目录\\Lib\\site-packages\\pyecharts\\datasets;pyecharts/datasets 第三个坑：运行时无法调用同目录下的csv文件 运行时，程序的实际工作目录并不是当前 EXE 文件所在的目录，而是临时生成的文件夹。\n为了解决这个问题，我在程序中添加了一些步骤来确认当前的工作目录：\ncurrent_dir = os.path.dirname(os.path.abspath(__file__)) print(f\u0026#34;Script directory: {current_dir}\u0026#34;) 发现输出的是一个TEMP文件夹，添加步骤设置工作目录后，正常运行。\nif getattr(sys, \u0026#39;frozen\u0026#39;, False): # 如果是打包后的可执行文件 current_dir = sys._MEIPASS else: # 如果是正常的脚本 current_dir = os.path.dirname(os.path.abspath(__file__)) print(f\u0026#34;Current directory: {current_dir}\u0026#34;) # 设置工作目录为当前目录 os.chdir(current_dir) "},{
  "section": "Blog",
  "slug": "/hugosite/blog/249011/",
  "title": "记录一次样式混淆 CSS 加密案例",
  "description": "this is meta description",
  "date": "April 4, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://s2.loli.net/2024/09/11/fUkb7Kj3osQXdwc.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://s2.loli.net/2024/09/11/fUkb7Kj3osQXdwc.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n",
  "searchKeyword": "",
  "categories": "Application, Data",
  "tags": "nextjs, tailwind",
  "content":" 猿人学web任务4：采集带有css加密的数据\n观察需要采集的数据 观察网页源码也能明显看出，每个数字由图片排列组合生成。\n测试发现不携带Cookie发送请求，返回的数据一致。没有通过Cookie加密。\n返回数据包中的\u0026rsquo;info\u0026rsquo; 是我们需要的数据，但是和网站文件数据有出入，可能经过解密后显示的。参数 key 和 value 高度可疑。\n经观察发现：\n所有的数字都是通过相同的10张数字图片组成的。后续数据可以直接识别地址推导出对应的数字\n数字的顺序通过css左右偏移来控制的，每个字符11.5的偏移量。例如第一个数据左边距0，那么就是在第一个位置。第二个数据左边距0，那么它就是在第二个位置。第三个数据左边距11.5px，那么它向右移一位，是第四个位置。第四个数据左边距 -11.5px ，那么它左移一位，为第三个位置。\n存在display:none的样式的数据不会显示在数据中，为干扰项。\n寻找加密入口 点击下一页是通过ajax加载的，在发出请求的位置打断点 一步步调试找到疑似加密函数的位置：\ndata 是请求返回的信息，根据代码可以看出加密逻辑:\n将info信息取出，加入到class name = number的数据中\nj_key 通过字符串处理以及某种加密函数得到。使用上面生成的选择器j_key找到对应的元素，并将它们的display属性设置为none，也就是隐藏这些元素。\n找到所有类名为img_number的元素，移除它们所有的类，然后重新添加img_number类。\n经过对比发现,返回数据的图片地址和传入html中的图片地址一致，图片地址并没有经过加密，加密的数据只有 j_key用于判断是否display\nJ_key 参数解密 在网站源文件可以搜索到hex_md5、bota等加密函数，把data数据传入后将整个函数取出测试：\nroot@DESKTOP-QKJKBB5:/home/zohar/work/crawer/No.4# nodejs test2.js .a0ad46ee666796be0fecdd5083374549 对比返回的数据中的info信息，可以找到大量class携带a0ad46ee666796be0fecdd5083374549的数据。由上面的加密逻辑可以知道，携带这个类的最后css样式会变为display: none\n编写采集程序 "},{
  "section": "Blog",
  "slug": "/hugosite/blog/249201/",
  "title": "逆向阿里系 acw_sc__v2 cookie js 加密",
  "description": "this is meta description",
  "date": "April 4, 2022",
  "image": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://s2.loli.net/2024/09/02/UtjGxf7ZrBhvbFW.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"\"\n    width=\"420\" /\u003e\n",
  "imageSM": "\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \u003cimg\n    loading=\"\"\n    decoding=\"async\"\n    src=\"https://s2.loli.net/2024/09/02/UtjGxf7ZrBhvbFW.png\"\n    alt=\"\"\n    class=\" img\"\n    height=\"100\"\n    width=\"100\" /\u003e\n",
  "searchKeyword": "",
  "categories": "Application, Data",
  "tags": "nextjs, tailwind",
  "content":" 阿里系网页比如淘宝，51job，雪球网等在无cookie爬取时经常爬取不到内容，返回的js中，常见 acw_sc__v2 的字眼。这里以雪球网为例，探索 acw_sc__v2 的加密以及应对方法。\n使用抓包工具测试，对 xueqiu.com/today 发起请求时，进行了两次 request ，第一次request 并没有返回任何数据，第二次返回的数据是我们需要的数据。由此猜测第一次不带cookie的请求时返回了cookie参数以及js加密方法，在本地经过js加密后获取到cookie发送第二次请求，服务端验证cookie后返回数据。\n编写测试的python进行测试，在请求头未携带cookie时返回如下图所示：\n返回了两个js函数，粗略观察后将js进行ob解混淆，得到以下内容：\nvar arg1 = \u0026#34;7542FA0F94F4AC555C13E601E5F6DD31D261AE1D\u0026#34;; function setCookie(name, value) { var expiredate = new Date(); expiredate.setTime(expiredate.getTime() + 3600000); document.cookie = name + \u0026#34;=\u0026#34; + value + \u0026#34;;expires=\u0026#34; + expiredate.toGMTString() + \u0026#34;;max-age=3600;path=/\u0026#34;; } function reload(x) { setCookie(\u0026#34;acw_sc__v2\u0026#34;, x); document.location.reload(); } var arg3 = null; var arg4 = null; var arg5 = null; var arg6 = null; var arg7 = null; var arg8 = null; var arg9 = null; var arg10 = null; var l = function () { while (window[\u0026#34;_phantom\u0026#34;] || window[\u0026#34;__phantomas\u0026#34;]) {} var _0x5e8b26 = \u0026#34;3000176000856006061501533003690027800375\u0026#34;; String[\u0026#34;prototype\u0026#34;][\u0026#34;hexXor\u0026#34;] = function (_0x4e08d8) { var _0x5a5d3b = \u0026#34;\u0026#34;; for (var _0xe89588 = 0; _0xe89588 \u0026lt; this[\u0026#34;length\u0026#34;] \u0026amp;\u0026amp; _0xe89588 \u0026lt; _0x4e08d8[\u0026#34;length\u0026#34;]; _0xe89588 += 2) { var _0x401af1 = parseInt(this[\u0026#34;slice\u0026#34;](_0xe89588, _0xe89588 + 2), 16); var _0x105f59 = parseInt(_0x4e08d8[\u0026#34;slice\u0026#34;](_0xe89588, _0xe89588 + 2), 16); var _0x189e2c = (_0x401af1 ^ _0x105f59)[\u0026#34;toString\u0026#34;](16); if (_0x189e2c[\u0026#34;length\u0026#34;] == 1) { _0x189e2c = \u0026#34;0\u0026#34; + _0x189e2c; } _0x5a5d3b += _0x189e2c; } return _0x5a5d3b; }; String[\u0026#34;prototype\u0026#34;][\u0026#34;unsbox\u0026#34;] = function () { var _0x4b082b = [15, 35, 29, 24, 33, 16, 1, 38, 10, 9, 19, 31, 40, 27, 22, 23, 25, 13, 6, 11, 39, 18, 20, 8, 14, 21, 32, 26, 2, 30, 7, 4, 17, 5, 3, 28, 34, 37, 12, 36]; var _0x4da0dc = []; var _0x12605e = \u0026#34;\u0026#34;; for (var _0x20a7bf = 0; _0x20a7bf \u0026lt; this[\u0026#34;length\u0026#34;]; _0x20a7bf++) { var _0x385ee3 = this[_0x20a7bf]; for (var _0x217721 = 0; _0x217721 \u0026lt; _0x4b082b[\u0026#34;length\u0026#34;]; _0x217721++) { if (_0x4b082b[_0x217721] == _0x20a7bf + 1) { _0x4da0dc[_0x217721] = _0x385ee3; } } } _0x12605e = _0x4da0dc[\u0026#34;join\u0026#34;](\u0026#34;\u0026#34;); return _0x12605e; }; var _0x23a392 = arg1[\u0026#34;unsbox\u0026#34;](); arg2 = _0x23a392[\u0026#34;hexXor\u0026#34;](_0x5e8b26); setTimeout(\u0026#34;reload(arg2)\u0026#34;, 2); }; var _0x4db1c = function () { function _0x355d23(_0x450614) { if ((\u0026#34;\u0026#34; + _0x450614 / _0x450614)[\u0026#34;length\u0026#34;] !== 1 || _0x450614 % 20 === 0) { (function () {})[\u0026#34;constructor\u0026#34;](\u0026#34;undefined\u0026#34;[2] + \u0026#34;true\u0026#34;[3] + ([][\u0026#34;entries\u0026#34;]() + \u0026#34;\u0026#34;)[2] + \u0026#34;undefined\u0026#34;[0] + (\u0026#34;false0\u0026#34; + String)[20] + (\u0026#34;false0\u0026#34; + String)[20] + \u0026#34;true\u0026#34;[3] + \u0026#34;true\u0026#34;[1])(); } else { (function () {})[\u0026#34;constructor\u0026#34;](\u0026#34;undefined\u0026#34;[2] + \u0026#34;true\u0026#34;[3] + ([][\u0026#34;entries\u0026#34;]() + \u0026#34;\u0026#34;)[2] + \u0026#34;undefined\u0026#34;[0] + (\u0026#34;false0\u0026#34; + String)[20] + (\u0026#34;false0\u0026#34; + String)[20] + \u0026#34;true\u0026#34;[3] + \u0026#34;true\u0026#34;[1])(); } _0x355d23(++_0x450614); } try { _0x355d23(0); } catch (_0x54c483) {} }; if (function () { var _0x470d8f = function () { var _0x4c97f0 = true; return function (_0x1742fd, _0x4db1c) { var _0x48181e = _0x4c97f0 ? function () { if (_0x4db1c) { var _0x55f3be = _0x4db1c[\u0026#34;apply\u0026#34;](_0x1742fd, arguments); _0x4db1c = null; return _0x55f3be; } } : function () {}; _0x4c97f0 = false; return _0x48181e; }; }(); var _0x501fd7 = _0x470d8f(this, function () { var _0x4c97f0 = function () { return \u0026#34;dev\u0026#34;; }, _0x1742fd = function () { return \u0026#34;window\u0026#34;; }; var _0x55f3be = function () { var _0x3ad9a1 = new RegExp(\u0026#34;\\\\w+ *\\\\(\\\\) *{\\\\w+ *[\u0026#39;|\\\u0026#34;].+[\u0026#39;|\\\u0026#34;];? *}\u0026#34;); return !_0x3ad9a1[\u0026#34;test\u0026#34;](_0x4c97f0[\u0026#34;toString\u0026#34;]()); }; var _0x1b93ad = function () { var _0x20bf34 = new RegExp(\u0026#34;(\\\\\\\\[x|u](\\\\w){2,4})+\u0026#34;); return _0x20bf34[\u0026#34;test\u0026#34;](_0x1742fd[\u0026#34;toString\u0026#34;]()); }; var _0x5afe31 = function (_0x178627) { var _0x1a0f04 = 0; if (_0x178627[\u0026#34;indexOf\u0026#34;](false)) { _0xd79219(_0x178627); } }; var _0xd79219 = function (_0x5792f7) { var _0x4e08d8 = 3; if (_0x5792f7[\u0026#34;indexOf\u0026#34;](\u0026#34;true\u0026#34;[3]) !== _0x4e08d8) { _0x5afe31(_0x5792f7); } }; if (!_0x55f3be()) { if (!_0x1b93ad()) { _0x5afe31(\u0026#34;indеxOf\u0026#34;); } else { _0x5afe31(\u0026#34;indexOf\u0026#34;); } } else { _0x5afe31(\u0026#34;indеxOf\u0026#34;); } }); _0x501fd7(); var _0x3a394d = function () { var _0x1ab151 = true; return function (_0x372617, _0x42d229) { var _0x3b3503 = _0x1ab151 ? function () { if (_0x42d229) { var _0x7086d9 = _0x42d229[\u0026#34;apply\u0026#34;](_0x372617, arguments); _0x42d229 = null; return _0x7086d9; } } : function () {}; _0x1ab151 = false; return _0x3b3503; }; }(); var _0x5b6351 = _0x3a394d(this, function () { var _0x46cbaa = Function(\u0026#34;return (function() {}.constructor(\\\u0026#34;return this\\\u0026#34;)( ));\u0026#34;); var _0x1766ff = function () {}; var _0x9b5e29 = _0x46cbaa(); _0x9b5e29[\u0026#34;console\u0026#34;][\u0026#34;log\u0026#34;] = _0x1766ff; _0x9b5e29[\u0026#34;console\u0026#34;][\u0026#34;error\u0026#34;] = _0x1766ff; _0x9b5e29[\u0026#34;console\u0026#34;][\u0026#34;warn\u0026#34;] = _0x1766ff; _0x9b5e29[\u0026#34;console\u0026#34;][\u0026#34;info\u0026#34;] = _0x1766ff; }); _0x5b6351(); try { return !!window[\u0026#34;addEventListener\u0026#34;]; } catch (_0x35538d) { return false; } }()) { document[\u0026#34;addEventListener\u0026#34;](\u0026#34;DOMContentLoaded\u0026#34;, l, false); } else { document[\u0026#34;attachEvent\u0026#34;](\u0026#34;onreadystatechange\u0026#34;, l); } _0x4db1c(); setInterval(function () { _0x4db1c(); }, 4000); 由此可见cookie中的重要参数 acw_sc_v2应该就是setCookie 函数生成的。\n只有携带acw_sc__v2才能正常返回数据。\n下一步测试setCookie函数的运行机制。\n因为Cookie是由JS加密生成的，这里我们将事件侦听中的脚本勾选进行调试。去除浏览器cookie后刷新页面。\n第一个执行的就是无Cookie下返回的js脚本：\n这里的 arg1 参数每次返回值都不同，是由服务器返回的。在后续加密中可能会用到。\n下一步会反复Reload Debugger界面：\n这里是防止Debug调试的，使用hook脚本过掉这个反Debug函数：\nFkdebug = Function.prototype.constructor; Function.prototype.constructor = function(a) { if(a == \u0026#34;debugger\u0026#34;){ return function (){}; } return Fkdebug(a); }; 这个脚本的作用是当构造函数传入debuger参数时返回空函数，不会再进入Debuger循环。\n同时注入一个hook脚本，用于追踪Cookie变化，方便后续调试逆向SetCookie加密函数：\n(function() { \u0026#39;use strict\u0026#39;; var _cookie = \u0026#34;\u0026#34;; // hook cookie Object.defineProperty(document, \u0026#39;cookie\u0026#39;, { set: function(val) { console.log(\u0026#39;cookie set-\u0026gt;\u0026#39;, new Date().getTime(), val); debugger; _cookie = val; return val; }, get: function() { return _cookie; } }); })() 下一步发现进入reload函数这个x值跟之前测试的时候携带Cookie中的acw_sc___v2值高度近似,猜测这个就是我们需要的值。上一步查看他由 I 函数加密生成的，其中的arg2就是我们需要的值。\n让我们返回第一次返回的加密js函数。容易找到L函数是主要的加密函数，剔除掉其他函数，保留l函数，其他函数主要是为了检测浏览器状态、页面加载状态相关的，调试过程中可能会报错。下面是AI对这段js代码的解释：\n这段代码的主要功能是实现一个JavaScript加密算法，用于加密和解密字符串。以下是代码的详细解释：\n定义变量arg1，其值为\u0026quot;B0B1F7133BA16D5E059D43020333D00BDB6D2E0E\u0026quot;。\n定义函数setCookie，用于设置cookie。\n定义函数reload，用于重新加载页面。\n定义变量arg3、arg4、arg5、arg6、arg7、arg8、arg9和arg10，其值均为null。\n定义函数l，用于实现加密算法。\n定义变量_0x4db1c，用于存储加密后的字符串。\n调用函数l，传入参数arg1，执行加密算法。\n调用函数setTimeout，传入参数reload(arg2)，设置延时为2毫秒，执行重新加载页面的操作。\n定义函数_0x4db1c，用于实现一个递归函数，用于检查页面的加载状态。\n调用函数_0x4db1c，传入参数0，执行递归函数。\n定义函数_0x501fd7，用于检查页面是否支持addEventListener方法。\n调用函数_0x501fd7，传入参数this和_0x4db1c，执行检查操作。\n如果页面支持addEventListener方法，则调用document.addEventListener，传入参数\u0026quot;DOMContentLoaded\u0026quot;和l，设置事件监听器。\n如果页面不支持addEventListener方法，则调用document.attachEvent，传入参数\u0026quot;onreadystatechange\u0026quot;和l，设置事件监听器。\n调用函数_0x4db1c，传入参数0，执行递归函数。\n调用函数setInterval，传入参数_0x4db1c，设置延时为4000毫秒，执行递归函数。\n总之，这段代码实现了一个加密算法，用于加密和解密字符串。同时，还检查了页面的加载状态，并在页面加载完成后执行加密算法。\n剔除后测试是否能正常生成arg2：\nroot@DESKTOP-QKJKBB5:/home/zohar/work/crawer# nodejs setcookie.js 66d2c9deb3158336006f0480e4b069112833b168 正常返回。\nEnd\n"}]
